/* -~=|AN|=~- */
/*
 *    This file is part of UnitTH
 *
 *   UnitTH is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   UnitTH is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with UnitTH if not, see <http://www.gnu.org/licenses/>.
 */

/*
 FIXME, BUG JUnit - Is there a bug in the trend calculations since we are getting the trend baseline
 from the spread with an index the same as the no of items in the spread. The highest index shall 
 be saved instead. Seems to be the case with all trend runs. More info needed.
 TODO, JUnit - Add test cases for trend calculations where test modules are not a part of a run.
 FIXME, All - First column in all tables shall be alphabetically sorted not just inverted.
 FIXME, All - Dynamic content in top frame OR remove frame for easier navigation, page bound content in top frame(s)
 TODO, JUnit - Navigate on package level
 TODO, All - Add footer to all pages, content = Page generated by UnitTH (junitth.sourceforge.net), color light gray
 TODO, All - Nicer HTML, check the SVD example on the sport pages. CSS and HTML has been grabbed.
 TODO, FitNesse - -fts Create new clean test reports that covers all trend aspects.
 TODO, FitNesse - -fts TestCases Local not implemented
 TODO, FitNesse - -fts TestCase spread Local not implemented
 FIXME, FitNesse - TestSuite trends.
 TODO, FitNesse - -fr Pass rate trend last 10 runs	
 TODO, FitNesse - -fr Pass rate trend last 3 days 		
 TODO, FitNesse - -fr Pass rate trend last 7 days 		
 TODO, FitNesse - -fr Test case trend last 3 days	
 TODO, FitNesse - -fr Test case trend last 7 days	
 TODO, FitNesse - -fr Failure trend last 3 days 		
 TODO, FitNesse - -fr Failure trend last 7 days 
 TODO, FitNesse - Sorting of all tables. FitNesse test cases.
 TODO, FitNesse - Possibility to parse multiple RTS using the -fts flag.
 FIXME, BUG FitNesse - Pass rate trend last run. Really not working. Dbg for
 page - FrontPage.SuiteUnitThRegression.SuiteJunitHtmlReportRedirect	
 There is a clear difference between test suites that has been executed 
 from the respective suite page versus suites that have been executed from the root.
 Review the way the spreads are created. Shall there be a different spread for RTS and TSs?
 FIXME, All - Create FitNesse tests that checks if the paths are absolute or relative. Fixture called from FitNesse.
 FIXME, FitNesse - spread table is too long on the FitNesse test suite pages.
 FIXME, FitNesse - clean up FitNesseHistoryHtmlGen
 FIXME, All - Fit all tables to page.
 TODO, All - Make sure there is FitNesse/Selenium test case that checks that no links are broken any where.
 TODO, FitNesse - Page anchors, how to test this with FitNesse?
 TODO, FitNesse - Decide on what to visualize on the main page.
 TODO, FitNesse - Decide on what to visualize on the test suite page.
 FIXME, FitNesse - Write unit tests for all FitNesse code.
 TODO, FitNesse - Pass rate graph, RootTestSuites narrow
 TODO, FitNesse - Pass rate graph, RootTestSuites tall 
 TODO, FitNesse - No Assertions graph, test suites
 TODO, FitNesse - No Exceptions rate graph, test suites
 TODO, FitNesse - No rights graph, test suites
 FIXME, All - Fully updated usage descriptions.
 FIXME, FitNesse - Tests, reference test suite that has clear trends run to run.
 FIXME, FitNesse - Tests, modularize the fts contents tests, test suite and rts page are basically the same.
 TODO, All - Remove framed solution and make sure the top part is navigatable by presenting 
 all the package levels - there shall be an orange URL present. If a package is empty 
 it shall me merged with the next package in the tree.
 TODO, FitNesse - Navigate on test suite level
 FIXME, All - create an OS switch in the build file so that the Selenium RC process can be killed on *us OSs as well.
 FIXME, FitNesse - How can the FitNesse tests pass even though the includes are not found.
 FIXME, FitNesse - add support for pageHistoryLink -> clickable from the test case spread page. 
 Will only work if the FitNesse server is up and running.
 FIXME, FitNesse - fintnesse-tmplogs shall be removed
 
 FIXME, V2.0 All - Add Maven examples.
 TODO, V2.0 Run app with Cobertura to remove dead code.
 TODO, V2.0 Add support for parsing FitNesse reports. 
 TODO, V2.0 Generate text summary intended for mailing.

 TODO, VX.X flag indicating usage of absolute paths or relative paths in report.
 TODO, VX.X Insert ok pass rate line in graph.
 TODO, VX.X Generate pdf, http://www-128.ibm.com/developerworks/opensource/library/os-javapdf/
 TODO, VX.X Draw graphs using the 1pxs stategy creating a huge HTML table?
 TODO, VX.X All graphs shall start at the first value not at 0,0. Perhaps redraw the entire graph using some other approaches.
 FIXME, VX.X Add HTML/FitNesse test cases to unit test suite. Generate pages and run them through an HTML validator.
 FIXME, VX.X rework passing of boolean flags to graph creation.
 FIXME, VX.X sort out object orientation aspects in test item classes. Test cases are not in the same category as modules or packages?
 */
package unitth.core;

import unitth.fitnesse.FitNesseReportParser;
import unitth.fitnesse.RootTestSuite;
import unitth.graphics.junit.ExecutionTimeGraphCreator;
import unitth.graphics.junit.FailureNumberGraphCreator;
import unitth.graphics.junit.PassRateGraphCreator;
import unitth.graphics.junit.TestCaseNumberGraphCreator;
import unitth.html.fitnesse.FitNesseHistoryHtmlMainGen;
import unitth.html.fitnesse.FitNesseHistoryHtmlTestSuiteGen;
import unitth.html.junit.HtmlMainGen;
import unitth.html.junit.HtmlModuleGen;
import unitth.html.junit.HtmlPackageGen;
import unitth.jenkins.JenkinsReportParser;
import unitth.junit.JUnitReportParser;
import unitth.junit.TestHistory;
import unitth.junit.TestModuleSummary;
import unitth.junit.TestPackageSummary;

import java.io.*;
import java.util.*;

/**
 * Main class responsible for reading/parsing the files that compromise the
 * JUnit test reports.
 */
public class UnitTH {
	public final static String versionNumber = "2.1";

	public static boolean c_DBG = false; // FIXME

	public final static String TEST_HISTORY_GRAPH_IMAGE_NAME = "th.png";
	public final static String TEST_CASE_NUMBERS_GRAPH_IMAGE_NAME = "tc.png";
	public final static String EXEC_TIME_NUMBERS_GRAPH_IMAGE_NAME = "et.png";
	public final static String EXEC_FAILURE_NUMBERS_GRAPH_IMAGE_NAME = "fn.png";

	private final static String PROPS_FILENAME = "unitth.properties";
	private final static String PROP_USE_ABS_PATHS = "unitth.use.absolute.paths"; 
	private final static String PROP_XML_REPORT_FILTER = "unitth.xml.report.filter";
	private final static String PROP_REPORT_DIR = "unitth.report.dir";
	private final static String PROP_HTML_REPORT_PATH = "unitth.html.report.path";
	private final static String PROP_GEN_EXECTIMEGRAPHS = "unitth.generate.exectimegraphs";
	
	public final static String NOT_IN_PACKAGE = "not-in-package";

	private static String c_HELP_TEXT = "\n"
			+ " UnitTH Copyright (C) 2010\n"
			+ " This program comes with ABSOLUTELY NO WARRANTY.\n"
			+ " This is free software, and you are welcome to redistribute it\n"
			+ " under certain conditions.\n\n"
			+ " Unit Test (report) history generator - UnitTH v"
			+ versionNumber
			+ "\n"
			+ "------------------------------------------------------\n"
			+ "This program is to be used for multiple generated\n"
			+ "test runs and test reports. The folders where\n"
			+ "the test results and generated reports are\n"
			+ "placed counts as input to this test history\n"
			+ "generator.\n"
			+ "\n"
			+ "Input and output properties shall be set using any of these three\n"
			+ "methods (given in the proprity order understood by the application,\n"
			+ "ie. system parameters overrides local properties).\n\n"
			+ " 1) as system parameters in build scripts\n"
			+ " 2) as D flags in Ant or Maven invocation\n"
			+ " 3) in unitth.properties in the working folder\n"
			+ " 4) in unitth.properties in the $HOME folder\n"
			+ "\n"
			+ "Example:\n"
			+ "\n"
			+ "> java -jar unitth.jar report_1 report_2 report_3\n"
			+ "\n"
			+ "> java -jar unitth.jar report_2009-*\n" + "\n"
			+ "\n"
			+ "> java -jar unitth.jar -j jenkinsInstallation/builds/unitth-job/builds\n" + "\n"
			//+ "\n"
			//+ "> java -jar unitth.jar -fr FitNesseInstallationFolder\n" + "\n"
			//+ "\n"
			//+ "> java -jar unitth.jar -fts FitNesseInstallationFolder/FitNesseRoot/files/testResults/FrontPage.TestSuite\n" + "\n"
			;

	private static String c_USAGE_TEXT = "\n"
			+ "UnitTH Copyright (C) 2010\n"
			+ "This program comes with ABSOLUTELY NO WARRANTY.\n"
			+ "This is free software, and you are welcome to redistribute it\n"
			+ "under certain conditions.\n\n"
			+ "   Test (report) history generator - UnitTH v"
			+ versionNumber
			+ "\n"
			+ "-----------------------------------------------------\n"
			+ "This program parses test results and test reports\n"
			+ "to generate a historical summary of results.\n"
			+ "\n"
			+ "Usage: java -jar unitth.jar --help\n"
			+ "\n"
			+ "Usage: java -jar unitth.jar <folder including generated XML and HTML results and report files> * N\n"
			+ "Example: java -jar unitth.jar report.th/report-0*\n"
			+ "\n"
			+ "Integration with Jenkins and Hudson can be done by using the -j or --jenkins flags. Note that the XML report file filter needs to be set to match junitResult.xml\n"
			+ "\n"
			+ "Usage: java -jar unitth.jar <-j|--jenkins> <Path to folder where all Jenkins reports have been generated. Usually <jenkins installation>/jobs/<job name>/builds\n"
			+ "Example: java -jar unitth.jar -j ../builds/unitth-job/builds\n"
			//+ "\n"
			//+ "Parsing FitNesse testresults can be done by using the flags -fr or --fitnesseroot.\n"
			//+ "\n"
			//+ "Usage: java -jar unitth.jar <-fts|--fitnesse-testsuite> <Path to folder where all FitNesse results have been generated. Usually FitNesseRoot/files/testResults>\n"
			//+ "Example: java -jar unitth.jar -fts ../FitNesseRoot/files/TestResults/FrontPage.TestSuite\n"
			//+ "\n"
			//+ "Usage: java -jar unitth.jar <-fr|--fitnesse-root> <Path to folder where all FitNesse results have been generated. Usually FitNesseRoot/files/testResults>\n"
			//+ "Example: java -jar unitth.jar -fr FitNesseInstallationFolder\n"
			;

	/*
	 * Input flags
	 */
	private static String c_FLAG_HELP_LONG = "--help";
	private static String c_FLAG_HELP_SHORT = "-h";
	private static String c_FITNESSE_REPORT_ROOT_LONG = "--fitnesse-root";
	private static String c_FITNESSE_REPORT_ROOT_SHORT = "-fr";
	private static String c_FITNESSE_REPORT_TESTSUITE_LONG = "--fitnesse-testsuite";
	private static String c_FITNESSE_REPORT_TESTSUITE_SHORT = "-fts";
	private static String c_JENKINS_REPORTS_SHORT = "-j";
	private static String c_JENKINS_REPORTS_LONG = "--jenkins";
	protected final int c_FILE_START_IDX = 0;
	protected final int c_FILE_START_IDX_FN = 1;
	public static final String c_VERSION_SHORT = "-v";
	public static final String c_VERSION_LONG = "--version";

	public static String[] inputArgs = null;
	private int startIndex = c_FILE_START_IDX;

	/*
	 * Properties with default values, or set from the unitth.properties file.
	 */
	public static String rootFolder = "report.th";
	public static String reportPath = ".";
	public static boolean generateExecTimeGraphs = false;
	public static boolean useAbsPaths = false;
	public static String xmlReportFilter = "TEST-";

	public static final String IMAGE_DIR = "images";
	public static final String CSS_DIR = "css";
	public static final String LOGO = "logo-unitth.jpg";
	public static final String BACK_ICON = "back-main.jpg";
	public static final String TRANS_IMAGE = "trans.gif";
	public static final String TREND_DOWN = "trend-down.jpg";
	public static final String TREND_DOWN_NEGATIVE = "trend-down-negative.jpg";
	public static final String TREND_SAME = "trend-same.jpg";
	public static final String ICON_HEIGHT = "16";
	public static final String ICON_WIDTH = "16";
	public static final String TREND_UP = "trend-up.jpg";
	public static final String TREND_UP_NEGATIVE = "trend-up-negative.jpg";
	public static final String CARET_UP_IMAGE = "caret_up.gif";
	public static final String CARET_DOWN_IMAGE = "caret_down.gif";
	public static final String CSS_FILE = "style.css";
	public static final String JS_DIR = "js";
	public static final String SORT_SCRIPT = "tablesort.js";
	public static final String c_FITNESSE_TESTHISTORY_PATH = "FitNesseRoot"+File.separator+"files"+File.separator+"testResults";
	
	/* Container for all run folders to be parsed. */
	protected ArrayList<ArrayList<File>> testRuns = null;
	
	/* Container for all the directories representing runs. */
	protected ArrayList<String> dirs = null;

	/* The file parser instance. */
	//protected JUnitReportParser junitParser = null;
	protected FitNesseReportParser fitNesseParser = null;
	protected ReportParser parser = null;

	/* Only to allow XML files. */
	private FilenameFilter filter = null;

	/** The data structure that holds all test runs. */
	protected RunHistory theHistory = null;

	/**
	 * The properties are read into this variable. Currently public for
	 * testability.
	 */
	public Properties properties = null;

	/**
	 * UnitTH entry point. Sets the Locale to US and creates the UnitTH object.
	 * 
	 * @param args
	 *            The command line arguments.
	 */
	public static void main(String[] args) {
		// We are using the US locale to keep all date and double formats
		// the same wherever we go.
		Locale.setDefault(Locale.US);

		if (null != System.getProperty("unitth.debug")) {
			if (System.getProperty("unitth.debug").equalsIgnoreCase("true")) {
				c_DBG = true; // default is false
			}
		}

		// Store away all args
		inputArgs = args;
		UnitTH thg = new UnitTH(args);
		if (c_DBG) {
			System.out.println(thg.toString());
		}
	}
	
	/**
	 *  The void CTOR. Used by test classes inheriting UnitTH. 
	 */
	public UnitTH() {
		// void
	}
	
	/**
	 * The CTOR, it handles the reading of all input files or prints usage texts
	 * in case of incorrect input.
	 * 
	 * @param args
	 *            The command line arguments.
	 */
	public UnitTH(String... args) {
		doTheStuff(args);
	}

	private void createFitNesseXMLFilter() {
		// Set up a filter that only picks XML files.
		filter = new FilenameFilter() {
			public boolean accept(File dir, String name) {
				return name.endsWith(".xml") && name.startsWith("2");
				// Up until year 2999
			}
		};
	}

	private void createJUnitXMLFilter() {
		// Set up a filter that only picks XML files.
		filter = new FilenameFilter() {
			public boolean accept(File dir, String name) {
				return (name.endsWith(".xml") || name.endsWith(".XML")) 
						&& name.startsWith(xmlReportFilter);
			}
		};
	}

	/**
	 * This is that handler for all input arguments and dispatches the correct
	 * functionality depending on flags.
	 * 
	 * @param args
	 *            The argument list as from the command line.
	 */
	private void doTheStuff(String... args) {
		// Handle all input arguments
		if (args.length == 0) {
			System.out.println(c_USAGE_TEXT);
			return;
		}
		if (args[0].equals(c_FLAG_HELP_LONG)
				|| args[0].equals(c_FLAG_HELP_SHORT)) {
			System.out.println(c_HELP_TEXT);
			return;
		}
		if (args[0].equals(c_VERSION_SHORT) || args[0].equals(c_VERSION_LONG)) {
			System.out.println("UnitTH version: " + versionNumber);
			return;
		}
		long timeStamp = System.currentTimeMillis();
		properties = new Properties();
		readProperties();

		if (args[0].equals(c_FITNESSE_REPORT_ROOT_SHORT)
				|| args[0].equals(c_FITNESSE_REPORT_ROOT_LONG)
				|| args[0].equals(c_FITNESSE_REPORT_TESTSUITE_LONG)
				|| args[0].equals(c_FITNESSE_REPORT_TESTSUITE_SHORT)) {
			fitNesseParser = new FitNesseReportParser();
			if (args[0].equals(c_FITNESSE_REPORT_ROOT_LONG)
					|| args[0].equals(c_FITNESSE_REPORT_ROOT_SHORT)) {
				if (args.length != 2) {
					wrongFitNesseRootInvocation();
				}
				parseAndCalculateFNRMultiple(args);
			} else {
				parseAndCalculateFNR(args);
			}
			unpackAndGenerateFNR();
			drawGraphs(true); // FitNesse reports
			long diff = System.currentTimeMillis() - timeStamp;
			System.out.println("\nA test history report has been generated in "
					+ diff + " ms at '" + rootFolder + "'.");
		}
		
		//
		// Handling of Jenkins reports
		//
		else if (args[0].equals(c_JENKINS_REPORTS_SHORT) || args[0].equals(c_JENKINS_REPORTS_LONG)) {
			if (args.length < 2) {
				wrongJenkinsInvocation();
			}
			parser = new JenkinsReportParser();
			
			//
			// Jenkins build root given. Now we need all the folders in here.
			//
			File jenkinsBuildDir = new File(args[c_FILE_START_IDX+1]);
			File[] builds;
			ArrayList<String> buildFolders = new ArrayList<String>();
			if (jenkinsBuildDir.exists()) {
				builds = jenkinsBuildDir.listFiles();
				for (int i=0; i<builds.length; i++) {
					if (builds[i].isDirectory()) {
						buildFolders.add(builds[i].getAbsolutePath());
					}
				}
			} else {
				System.err.println("Jenkins build reports folder '"+jenkinsBuildDir.getAbsolutePath()+"' does not exists, please check the input arguments '-j <folder path>'.");
			}
			
			if (parseAndCalculate(buildFolders.toArray(new String[0]))) {
				unpackAndGenerate();
				drawGraphs(false); // JUnit reports
				long diff = System.currentTimeMillis() - timeStamp;
				System.out
						.println("\nA test history report has been generated in "
								+ diff + " ms at '" + rootFolder + "'.");
			}
		}
		else {
			parser = new JUnitReportParser();
			if (parseAndCalculate(args)) {
				unpackAndGenerate();
				
				// Sanity check, no tests found no need to generate anything
				if (((unitth.junit.TestHistory)theHistory).getNoExecutedTestCases() < 1) {
					System.err.println("No test cases has been parsed, skipping report generation.");
					return;
				}
				
				drawGraphs(false); // JUnit reports
				long diff = System.currentTimeMillis() - timeStamp;
				System.out
						.println("\nA test history report has been generated in "
								+ diff + " ms at '" + rootFolder + "'.");
			}
		}
	}

	private void unpackAndGenerate() {

		// First extract the css and image files to the correct locations.
		try {
			createDir(rootFolder);
			createDir(rootFolder+File.separator+IMAGE_DIR);
			extractFilesFromJar();
		} catch (Exception e) {
			e.printStackTrace();
			return;
		}
		if (null != theHistory) {
			HtmlMainGen htmlMainGen = new HtmlMainGen((TestHistory) theHistory,
					generateExecTimeGraphs);
			htmlMainGen.generateHtmlHistory();
			HtmlPackageGen htmlPackageGen = new HtmlPackageGen(
					(TestHistory) theHistory, generateExecTimeGraphs);
			htmlPackageGen.generateHtmlHistory();
			HtmlModuleGen htmlModuleGen = new HtmlModuleGen(
					(TestHistory) theHistory, generateExecTimeGraphs);
			htmlModuleGen.generateHtmlHistory();
		}
	}

	private void unpackAndGenerateFNR() {

		// First extract the css and image files to the correct locations.
		try {
			createDir(rootFolder);
			extractFilesFromJar();
		} catch (Exception e) {
			e.printStackTrace();
		}

		if (null != theHistory) {
			FitNesseHistoryHtmlMainGen htmlMainGen = new FitNesseHistoryHtmlMainGen(
					(unitth.fitnesse.TestHistory) theHistory,
					generateExecTimeGraphs);
			htmlMainGen.generateHtmlHistory();

			Collection<RootTestSuite> crts = ((unitth.fitnesse.TestHistory) theHistory)
					.getRootTestSuites();
			Iterator<RootTestSuite> irts = crts.iterator();

			while (irts.hasNext()) {
				RootTestSuite rts = irts.next();
				FitNesseHistoryHtmlTestSuiteGen htmlTestSuiteGen = new FitNesseHistoryHtmlTestSuiteGen(
						(unitth.fitnesse.TestHistory) theHistory,
						generateExecTimeGraphs);
				htmlTestSuiteGen.generateHtmlHistory(rts.getName());
			}
		}
	}

	private void collectAllFiles(String... args) throws Exception {
		// Parse all valid files...
		dirs = new ArrayList<String>();
		testRuns = new ArrayList<ArrayList<File>>();

		try {
			for (int i = startIndex; i < args.length; i++) {

				// Get directories and list files
				File d = new File(args[i]);
				if (!d.exists()) {
					throw new UnitTHException("Folder '"+d.getAbsoluteFile()+"' given as input argument does not exist.");
				}
				
				if (d.isDirectory()) {

					ArrayList<File> testRunFiles = new ArrayList<File>();
					createJUnitXMLFilter();
					File[] ff = d.listFiles(filter);
					for (File f : ff) {
						if (fileSanityCheck(f)) {
							testRunFiles.add(f);
						}
					}
					if (testRunFiles.size() > 0) {
						dirs.add(args[i]);
						// All files in folder has been parsed.
						// Now add the list to test run
						testRuns.add(testRunFiles);
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		}
	}

	private void collectAllFilesFNR(String... args) throws Exception {

		FileFilter dirFilter = new FileFilter() {
			public boolean accept(File dir) {
				return dir.isDirectory();// Up until year 2999
			}
		};

		testRuns = new ArrayList<ArrayList<File>>();

		// list and store all folders in the input folder(s) to identify all
		// root nodes.
		try {

			// For every folder in the argument list.
			for (int i = c_FILE_START_IDX_FN; i < args.length; i++) {

				// Create a folder to look for directories or files.
				File d = new File(args[i]);

				// If the argument was a folder, start searching
				if (d.isDirectory()) {
					File[] runFiles;
					ArrayList<File> testRunFiles = new ArrayList<File>();

					// First get all possible root directories in this folder.
					File[] testSuiteDirs = d.listFiles(dirFilter);

					// If there are no directories we are in test suite folder.
					if (0 <= testSuiteDirs.length) {
						createFitNesseXMLFilter(); // FileNameFilter
						runFiles = d.listFiles(filter);

						for (File ff : runFiles) {
							testRunFiles.add(ff);
						}
						if (testRunFiles.size() > 0) {
							testRuns.add(testRunFiles);
						}
					} else {
						System.out
								.println("\n\nNOT IMPLEMENTED!! - use the folder with all reports to be parsed.\n\n");
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		}
	}

	public boolean parseAndCalculateFNR(String... args) {
		try {
			collectAllFilesFNR(args);
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(0);
		}
		if (0 < testRuns.size()) {
			theHistory = fitNesseParser.parseRuns(testRuns);
			theHistory.calcStats();
		} else {
			System.err.println("There are no files to parse!");
			System.out.println(c_USAGE_TEXT);
			System.exit(0);
		}

		return true;
	}
	
	private void collectAllFilesFNRMultiple(String[] args) {
		// The testHistory folder.
		String testHistoryStr;
		if (args[1].endsWith("/") || args[1].endsWith("\\") || args[1].endsWith("\\\\")) {
			testHistoryStr = args[1]+c_FITNESSE_TESTHISTORY_PATH;
		} else {
			testHistoryStr = args[1]+File.separator+c_FITNESSE_TESTHISTORY_PATH;
		}
		
		//ArrayList<ArrayList<File>> fullFileSet = new ArrayList<ArrayList<File>>();
		testRuns = new ArrayList<ArrayList<File>>();
		File fitNesseTestHistory = new File(testHistoryStr);
		
		if (fitNesseTestHistory.exists()) {
			
			if (c_DBG) {
				System.out.println("Checking if file is valid FitNesse test suite history."); // Leave or remove?
			}
			for (File f : fitNesseTestHistory.listFiles()) {
				if (f.isDirectory()) {
					ArrayList<File> suiteFiles = new ArrayList<File>();
					File[] files = f.listFiles();
					for (int i=0; i<files.length; i++) {
						if (files[i].isFile()) {
							if (c_DBG) {
								System.out.print(".");
							}
							String fileName = files[i].getName();
							if (fileName.endsWith(".xml") || fileName.endsWith(".XML")) {
								// Check for presence of  
								FileCheckingParser fcp = new FileCheckingParser();
								if (fcp.parse(files[i]) == true) {
									suiteFiles.add(files[i]);
								}
							}
						}
					}
					if (suiteFiles.size() > 0) {
						testRuns.add(suiteFiles);
					}
				}
			}
		} else {
			wrongFitNesseRootInvocation();
		}
	}
	
	public boolean parseAndCalculateFNRMultiple(String... args) {
		
		try {
			collectAllFilesFNRMultiple(args);
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(0);
		}
		if (0 < testRuns.size()) {
			theHistory = fitNesseParser.parseRuns(testRuns);
			theHistory.calcStats();
		} else {
			System.err.println("There are no files to parse!");
			System.out.println(c_USAGE_TEXT);
			System.exit(0);
		}
		return true;
	}
	
	/**
	 * Handles all the tasks to be done during execution. - list all files -
	 * parse all files - generate history report. Needs to be public so that we
	 * can use it for generating data for the tests.
	 * 
	 * @param args
	 *            The command line arguments passed from main
	 * @return True or false depending on how well things went.
	 */
	public boolean parseAndCalculate(String... args) {
		try {
			collectAllFiles(args);
		} catch(UnitTHException uthe) {
			System.err.println(uthe.getMessage());
			return false;
		} catch (Exception e) {
			System.err.println(e.getMessage());
			return false;
		}

		if (0 < testRuns.size()) {
			theHistory = parser.parseRuns(testRuns, dirs);
		} else {
			System.err
					.println("There are no files to parse! Check the input parameters and properties.");
			System.out.println(c_USAGE_TEXT);
			return false;
		}

		if (null != theHistory) {
			// Major, calculation for all parsed runs.
			theHistory.calcStats();

			if (true == c_DBG && theHistory != null) {
				System.out.println(theHistory.toString());
			}
			return true;
		} else {
			return false;
		}
	}

	/*
	 * Creates a directory with the name given in the in-parameter dir.
	 * 
	 * @param dir The name of the directory to create.
	 */
	private void createDir(String dir) {
		File outputDir = new File(dir);
		try {
			outputDir.mkdir();
		} catch (SecurityException se) {
			se.printStackTrace();
		}
	}

	/*
	 * Creates a directory with the name given in the in-parameter dir in the
	 * parent directory given by parameter parent.
	 * 
	 * @param parent The name of the parent directory.
	 * @param dir The name of the directory to create.
	 */
	private void createDir(String parent, String dir) {
		File outputDir = new File(parent, dir);
		try {
			outputDir.mkdirs();
		} catch (SecurityException se) {
			se.printStackTrace();
		}
	}

	/*
	 * Extracts the CSS and fixed image files stored inside the built jarfile.
	 */
	private void extractFilesFromJar() throws IOException, UnitTHException {
		try {
			String outputName = rootFolder + File.separator + "css"
					+ File.separator + CSS_FILE;
			getFileFromJar("/"+CSS_DIR+"/" + CSS_FILE, outputName, CSS_DIR);

			outputName = rootFolder + File.separator + IMAGE_DIR
					+ File.separator + TRANS_IMAGE;
			getFileFromJar("/"+IMAGE_DIR+"/" + TRANS_IMAGE, outputName, IMAGE_DIR);

			outputName = rootFolder + File.separator + IMAGE_DIR
					+ File.separator + BACK_ICON;
			getFileFromJar("/"+IMAGE_DIR+"/" + BACK_ICON, outputName, IMAGE_DIR);

			outputName = rootFolder + File.separator + IMAGE_DIR
					+ File.separator + LOGO;
			getFileFromJar("/"+IMAGE_DIR+"/" + LOGO, outputName, IMAGE_DIR);

			outputName = rootFolder + File.separator + IMAGE_DIR
					+ File.separator + TREND_DOWN;
			getFileFromJar("/"+IMAGE_DIR+"/" + TREND_DOWN, outputName, IMAGE_DIR);

			outputName = rootFolder + File.separator + IMAGE_DIR
					+ File.separator + TREND_SAME;
			getFileFromJar("/"+IMAGE_DIR+"/" + TREND_SAME, outputName, IMAGE_DIR);

			outputName = rootFolder + File.separator + IMAGE_DIR
					+ File.separator + TREND_UP;
			getFileFromJar("/"+IMAGE_DIR+"/" + TREND_UP, outputName, IMAGE_DIR);

			outputName = rootFolder + File.separator + IMAGE_DIR
			+ File.separator + TREND_DOWN_NEGATIVE;
			getFileFromJar("/"+IMAGE_DIR+"/" + TREND_DOWN_NEGATIVE, outputName, IMAGE_DIR);

			outputName = rootFolder + File.separator + IMAGE_DIR
			+ File.separator + TREND_UP_NEGATIVE;
			getFileFromJar("/"+IMAGE_DIR+"/" + TREND_UP_NEGATIVE, outputName, IMAGE_DIR);
	
			outputName = rootFolder + File.separator + IMAGE_DIR
					+ File.separator + CARET_DOWN_IMAGE;
			getFileFromJar("/"+IMAGE_DIR+"/" + CARET_DOWN_IMAGE, outputName, IMAGE_DIR);

			outputName = rootFolder + File.separator + IMAGE_DIR
					+ File.separator + CARET_UP_IMAGE;
			getFileFromJar("/"+IMAGE_DIR+"/" + CARET_UP_IMAGE, outputName, IMAGE_DIR);

			outputName = rootFolder + File.separator + JS_DIR + File.separator
					+ SORT_SCRIPT;
			getFileFromJar("/javascript/" + SORT_SCRIPT, outputName, JS_DIR);
		} catch (IOException ioe) {
			ioe.printStackTrace();
			throw ioe;
		} catch (UnitTHException uthe) {
			uthe.printStackTrace();
			throw uthe;
		}
	}

	/*
	 * Extracts a specific file given by the in-parameter fileName from the
	 * jar-file given by the in-parameter jarFile.
	 * 
	 * @param jarFile Name of the jar file to extract the file fileName from.
	 * @param fileName The name of the file to extract.
	 * @param outputName The name to give the output file.
	 * @param dest The target destination for the extracted file.
	 * @throws IOException
	 */
	public void getFileFromJar(String fileName, String outputName, String dest)
			throws IOException, UnitTHException {

		InputStream in = this.getClass().getResourceAsStream(fileName);
		if (null == in) {
			throw new UnitTHException("Could not extract '" + fileName
					+ "' from jar file (target dir: '"+dest+"').");
		}
		createDir(rootFolder, dest);
		OutputStream out = new FileOutputStream(outputName);
		int c;
		while ((c = in.read()) != -1) {
			out.write(c);
		}
		in.close();
		out.close();
	}

	/*
	 * Checks whether the file is an existing file or not.
	 * 
	 * @param inFile The file objects to verify.
	 * 
	 * @return Returns true if inFile is a file.
	 * 
	 * @throws UnitTHException
	 */
	private boolean fileSanityCheck(File inFile) {

		if (!inFile.isFile()) {
			return false;
		}
		return true;
	}

	/**
	 * Creates the CraphCreator object ant initiates the drawing of the pass
	 * rate and test case execution graphs.
	 */
	public void drawGraphs(boolean isFitNesse) {

		PassRateGraphCreator prGraphCreator = null;
		TestCaseNumberGraphCreator tcGraphCreator = null;
		FailureNumberGraphCreator fnGraphCreator = null;
		ExecutionTimeGraphCreator etGraphCreator = null;
		if (isFitNesse) {

		} else {
			prGraphCreator = new PassRateGraphCreator(
					(unitth.junit.TestHistory) theHistory);
			tcGraphCreator = new TestCaseNumberGraphCreator(
					(unitth.junit.TestHistory) theHistory);
			fnGraphCreator = new FailureNumberGraphCreator(
					(unitth.junit.TestHistory) theHistory);
			etGraphCreator = new ExecutionTimeGraphCreator(
					(unitth.junit.TestHistory) theHistory);
		}

		// All images for the main page
		if (isFitNesse) {

			Object[] tsss = ((unitth.fitnesse.TestHistory) theHistory)
					.getUniqueTestSuites();

			for (Object oo : tsss) {
				// TestSuiteSummary tss = (unitth.fitnesse.TestSuiteSummary) oo;
				// if (null != tss) {
				// FIXME, part of FitNesse implementation
				// prGraphCreator.drawPassRates(tss);
				// tcGraphCreator.drawNumbers(tss);
				// fnGraphCreator.drawNumbers(tss);
				// etGraphCreator.drawExecutionTimes(tss,
				// generateExecTimeGraphs);
				// }
			}

		} else {
			//
			// This section generates everything for the JUnit test reports.
			// 
			prGraphCreator.drawPassRates();
			tcGraphCreator.drawNumbers();
			fnGraphCreator.drawNumbers();
			etGraphCreator.drawExecutionTimes(generateExecTimeGraphs);
			
			// For each unique package name, get a test package summary that
			// can be used for creating the unique test module graphs.
			Object[] uniquePackages = ((TestHistory) theHistory)
					.getUniquePackages();
			for (Object packageName : uniquePackages) {
				TestPackageSummary tps = ((TestHistory) theHistory)
						.getTestPackageSummary((String) packageName);
				if (null != tps) {
					prGraphCreator.drawPassRates(tps);
					tcGraphCreator.drawNumbers(tps);
					fnGraphCreator.drawNumbers(tps);
					etGraphCreator.drawExecutionTimes(tps,
							generateExecTimeGraphs);
				}
			}
			
			// For each unique module name, get a test module summary that
			// can be used for creating the unique test module graphs.
			Object[] uniqueModules = ((TestHistory) theHistory)
					.getUniqueModules();
			for (Object moduleName : uniqueModules) {
				TestModuleSummary tms = ((TestHistory) theHistory)
						.getTestModuleSummary((String) moduleName);
				if (null != tms) {
					prGraphCreator.drawPassRates(tms);
					tcGraphCreator.drawNumbers(tms);
					fnGraphCreator.drawNumbers(tms);
					etGraphCreator.drawExecutionTimes(tms,
							generateExecTimeGraphs);
				}
			}
		}
	}

	/*
	 * This method looks for the exec time graph property.
	 */
	private void getExecutionTimeProp(File runProps, File homeProps) {

		// First check if there is a system property
		if (null != System.getProperty(PROP_GEN_EXECTIMEGRAPHS)) {
			setGenerateExecTimeGraphs(System.getProperty(PROP_GEN_EXECTIMEGRAPHS));
			return;
		}

		try {
			// Check in the run folder
			if (runProps.exists()) {
				properties.load(new FileInputStream(runProps));
				if (null != properties
						.getProperty(PROP_GEN_EXECTIMEGRAPHS)) {
					setGenerateExecTimeGraphs(properties.getProperty(PROP_GEN_EXECTIMEGRAPHS));
				}
				return;
			}

			// Check in the home folder
			if (homeProps.exists()) {
				properties.load(new FileInputStream(homeProps));
				if (null != properties
						.getProperty(PROP_GEN_EXECTIMEGRAPHS)) {
					setGenerateExecTimeGraphs(properties.getProperty(PROP_GEN_EXECTIMEGRAPHS));
				}
				return;
			}
		} catch (IOException ioe) {
			System.err
					.println("Problems parsing the properties file... using default settings instead.");
		}
	}

	private void getJunitReportPathProp(File runProps, File homeProps) {
		if (null != System.getProperty(PROP_HTML_REPORT_PATH)) {
			reportPath = System.getProperty(PROP_HTML_REPORT_PATH);
			return;
		}
		try {
			// Check in the run folder
			if (runProps.exists()) {
				properties.load(new FileInputStream(runProps));
				String propHolder = properties
						.getProperty(PROP_HTML_REPORT_PATH);
				if (null != propHolder && !propHolder.equals("")) {
					reportPath = propHolder;
				}
				return;
			}
			// Check in the home folder
			if (homeProps.exists()) {
				properties.load(new FileInputStream(homeProps));
				String propHolder = properties
						.getProperty(PROP_HTML_REPORT_PATH);
				if (null != propHolder && !propHolder.equals("")) {
					reportPath = propHolder;
				}
				return;
			}
		} catch (IOException ioe) {
			System.err
					.println("Problems parsing the properties file... using default settings instead.");
		}
	}

	private void getReportDirProp(File runProps, File homeProps) {
		if (null != System.getProperty(PROP_REPORT_DIR)) {
			rootFolder = System.getProperty(PROP_REPORT_DIR);
			return;
		}
		try {// Check in the run folder
			if (runProps.exists()) {
				properties.load(new FileInputStream(runProps));
				String propHolder = properties.getProperty(PROP_REPORT_DIR);

				if (null != propHolder && !propHolder.equals("")) {
					rootFolder = propHolder;
				}
				return;
			}
			// Check in the home folder
			if (homeProps.exists()) {
				properties.load(new FileInputStream(homeProps));
				String propHolder = properties.getProperty(PROP_REPORT_DIR);
				if (null != propHolder && !propHolder.equals("")) {
					rootFolder = propHolder;
				}
				return;
			}
		} catch (IOException ioe) {
			System.err
					.println("Problems parsing the properties file... using default settings instead.");
		}
	}

	private void getXmlFilterProp(File runProps, File homeProps) {
		if (null != System.getProperty(PROP_XML_REPORT_FILTER)) {
			xmlReportFilter = System.getProperty(PROP_XML_REPORT_FILTER);
			return;
		}
		try {// Check in the run folder
			if (runProps.exists()) {
				properties.load(new FileInputStream(runProps));
				String propHolder = properties
						.getProperty(PROP_XML_REPORT_FILTER);
				if (null != propHolder && !propHolder.equals("")) {
					xmlReportFilter = propHolder;
				}
				return;
			}
			// Check in the home folder
			if (homeProps.exists()) {
				properties.load(new FileInputStream(homeProps));
				String propHolder = properties
						.getProperty(PROP_XML_REPORT_FILTER);
				if (null != propHolder && !propHolder.equals("")) {
					xmlReportFilter = propHolder;
				}
				return;
			}
		} catch (IOException ioe) {
			System.err
					.println("Problems parsing the properties file... using default settings instead.");
		}
	}

	private void getAbsPathsProp(File runProps, File homeProps) {
		// First check if there is a system property
		if (null != System.getProperty(PROP_USE_ABS_PATHS)) {
			setUseAbsPaths(System.getProperty(PROP_USE_ABS_PATHS));
			return;
		}

		try {
			// Check in the run folder
			if (runProps.exists()) {
				properties.load(new FileInputStream(runProps));
				if (null != properties
						.getProperty(PROP_USE_ABS_PATHS)) {
					setUseAbsPaths(properties.getProperty(PROP_USE_ABS_PATHS));
				}
				return;
			}

			// Check in the home folder
			if (homeProps.exists()) {
				properties.load(new FileInputStream(homeProps));
				if (null != properties
						.getProperty(PROP_USE_ABS_PATHS)) {
					setUseAbsPaths(properties.getProperty(PROP_USE_ABS_PATHS));
				}
				return;
			}
		} catch (IOException ioe) {
			System.err
					.println("Problems parsing the properties file... using default settings instead.");
		}
	}
	
	private void setUseAbsPaths(String value) {
		if (value.equalsIgnoreCase("true")
				|| value.equalsIgnoreCase("yes")) {
			useAbsPaths = true;
		} else {
			useAbsPaths = false;
		}
	}
	
	private void setGenerateExecTimeGraphs(String value) {
		if (value.equalsIgnoreCase("true")
				|| value.equalsIgnoreCase("yes")) {
			generateExecTimeGraphs = true;
		} else {
			generateExecTimeGraphs = false;
		}
	}
	
	/**
	 * Reads properties one by one in the following order. 1) System properties,
	 * ie -D flags 2) From the run folder unitth.properties file. 3) From the
	 * $home folder unitth.properties file.
	 */
	public void readProperties() {

		// Try two different locations, $HOME and .
		File runPropertiesFile = new File(System.getProperty("user.dir")
				+ File.separator + PROPS_FILENAME);
		File homePropertiesFile = new File(System.getProperty("user.home")
				+ File.separator + PROPS_FILENAME);

		getExecutionTimeProp(runPropertiesFile, homePropertiesFile);
		getJunitReportPathProp(runPropertiesFile, homePropertiesFile);
		getReportDirProp(runPropertiesFile, homePropertiesFile);
		getXmlFilterProp(runPropertiesFile, homePropertiesFile);
		getAbsPathsProp(runPropertiesFile, homePropertiesFile);
		
		properties.setProperty(PROP_HTML_REPORT_PATH, reportPath);
		properties.setProperty(PROP_REPORT_DIR, rootFolder);
		properties.setProperty(PROP_XML_REPORT_FILTER, xmlReportFilter);
		properties.setProperty(PROP_GEN_EXECTIMEGRAPHS, Boolean.toString(generateExecTimeGraphs));
		properties.setProperty(PROP_USE_ABS_PATHS, Boolean.toString(useAbsPaths));
		
		System.out.println("Using the following properties");
		System.out.println(" "+PROP_HTML_REPORT_PATH+" = " + reportPath);
		System.out.println(" "+PROP_REPORT_DIR+" = " + rootFolder);
		System.out.println(" "+PROP_XML_REPORT_FILTER+" = " + xmlReportFilter);
		System.out.println(" "+PROP_GEN_EXECTIMEGRAPHS+" = "
				+ generateExecTimeGraphs);
		System.out.println(" "+PROP_USE_ABS_PATHS+" = "
				+ useAbsPaths);
	}
	
	private void wrongFitNesseRootInvocation() {
		System.out.println("The FitNesse root flags (-fr --fitnesse-root) are beeing used. Make sure that there are only one argument provided that points to the FitNesse installation folder.\n");
		System.exit(0);
	}
	
	private void wrongJenkinsInvocation() {
		System.out.println("The Jenkins invokation flags (-j --jenkins) are beeing used. Make sure that there are only one additional argument provided that points to the folders where jenkins stores its report files.\n");
		System.exit(0);
	}
}

/* eof */
